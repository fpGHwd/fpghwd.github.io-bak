<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WD's BLOG (Posts about emacs)</title><link>https://fpghwd.github.io/</link><description></description><atom:link href="https://fpghwd.github.io/categories/emacs.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:ggwdwhu@gmail.com"&gt;Wang Ding&lt;/a&gt; </copyright><lastBuildDate>Mon, 08 Mar 2021 08:09:32 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Macos emacs-plus@27 is convenient with emacs-rime</title><link>https://fpghwd.github.io/posts/macos-emacs-plus27-is-convenient-with-emacs-rime/</link><dc:creator>Wang Ding</dc:creator><description>&lt;p&gt;
不知道是不是我的配置问题，使用相同的配置 emacs-plus@28 –with-native-comp 就非常的卡，然后马上退回 emacs-plus@27 。感觉 emacs-rime 在长的 org 文件中编辑也不会卡。
&lt;/p&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/macos-emacs-plus27-is-convenient-with-emacs-rime/</guid><pubDate>Wed, 03 Mar 2021 07:56:33 GMT</pubDate></item><item><title>Emacs mouse or touchpad scroll line by line</title><link>https://fpghwd.github.io/posts/emacs-mouse-or-touchpad-scroll-line-by-line/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
Just set &lt;code&gt;mouse-wheel-progressive-speed&lt;/code&gt; to &lt;code&gt;nil&lt;/code&gt; in init file.
&lt;/p&gt;

&lt;p&gt;
如果需要的话，也可以在对下面进行设置，不过我觉得有了上面的设置已经差不多了。关于 &lt;code&gt;mouse-wheel-progressive-speed&lt;/code&gt; 的解释是：
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
If non-nil, the faster the user moves the wheel, the faster the scrolling.
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-emacs"&gt;
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1))) ;; one line at a time
(setq mouse-wheel-progressive-speed nil) ;; don't accelerate scrolling
(setq mouse-wheel-follow-mouse 't) ;; scroll window under mouse
(setq scroll-step 1) ;; keyboard scroll one line at a time

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-mouse-or-touchpad-scroll-line-by-line/</guid><pubDate>Sun, 14 Feb 2021 12:06:23 GMT</pubDate></item><item><title>Org-roam</title><link>https://fpghwd.github.io/posts/org-roam/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近又重拾 org-roam 来做记录。我喜欢这个工具的重大原因是：它是解耦的，另外它是可拓展的。也许正是因为它是解耦的所以它的可拓展性很高吧。
&lt;/p&gt;

&lt;p&gt;
不过我并没有一定要记录很多的 org-roam 卡片，不过这些卡片本身具有解耦的特征，因此对于分析问题应该好处特别的明显。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/org-roam/</guid><pubDate>Sun, 24 Jan 2021 12:56:20 GMT</pubDate></item><item><title>Emacs 自动保存文件设置</title><link>https://fpghwd.github.io/posts/emacs-zi-dong-bao-cun-wen-jian-she-zhi/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
Emacs 自带文件自动保存的机制，利用 &lt;code&gt;do-auto-save&lt;/code&gt; 可以自动存储当前编辑的文件为一个编辑过的复本，并未直接存储到 buffer 对应的文件中。当然也可以直接开启全局的 &lt;code&gt;(auto-save-visited-mode t)&lt;/code&gt; ，在默认的 &lt;code&gt;auto-save-visited-interval&lt;/code&gt; 时间（默认 5 秒），后会自动将已经修改后的 buffer 内容写入文件中。
&lt;/p&gt;

&lt;p&gt;
其中使用 &lt;code&gt;do-auto-save&lt;/code&gt; 保存的文件的复本可以在打开该文件本身时有提示。这是一个好的地方，也是容易忽略的地方：某次并没有将改动保存到文件，而是自动保存到了某个复本，而下一次用 emacs 打开该文件，虽然 emacs 有提醒该文件有复本未保存到文件中，此时极有可能形成了两个新的基于原文件改动的分枝。众所周知，合并文件是一件耗时的事情。所以我觉得还是打开 &lt;code&gt;(auto-save-visited-mode t)&lt;/code&gt; 更好，避免形成两个改动文件并且需要合并内容的情形。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-zi-dong-bao-cun-wen-jian-she-zhi/</guid><pubDate>Wed, 23 Dec 2020 12:06:34 GMT</pubDate></item><item><title>Emacs 下同时查看和编辑一个文件的多个 headline: 使用 Indirect Buffer</title><link>https://fpghwd.github.io/posts/emacs-open-several-windows-with-specific-org-narrowed-headline/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
在使用 emacs 编辑一个很多的 headlines 的 org 文件时，如果每个 headline 下的内容需要交叉查看和编辑的时候，我就非常需要一个单独的 windows(emacs 下的窗口，下均同) 仅显示一个 headline 下的所有内容，所以必须用到 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 这个函数。
&lt;/p&gt;

&lt;p&gt;
但是在第一次使用这个函数后，就无法看到其他的 headlines ，所以想在多个窗口中打开多个 headlines 仅使用 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 是不够的。好在有了 &lt;code&gt;clone-indirect-buffer&lt;/code&gt; 可以复制一个当前文件的 buffer 。一般情况下，在使用 emacs 打开文件的时候，我们只能在将一个文件绑定在一个 buffer 中，这个函数可以让我们将一个文件绑定在多个 buffer 中。
&lt;/p&gt;

&lt;p&gt;
然后在不同的 windows 中打开相同文件的不同 buffer ，可以看到这个文件的不同 headlines ，进而使用对不同的 headline 使用 &lt;code&gt;org-narrow-to-subtree&lt;/code&gt; 来实现“在不同的 windows 里面查看一个文件中不同 headlines 的 &lt;code&gt;org-narrow-subtree&lt;/code&gt; ”。
&lt;/p&gt;

&lt;p&gt;
这个功能对于我来说很实用，尤其是对一个比较长的， subtree 又比较多的 org 文件中同时查看和编辑多个 headline 的情况下尤其有用。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-open-several-windows-with-specific-org-narrowed-headline/</guid><pubDate>Tue, 15 Dec 2020 08:04:30 GMT</pubDate></item><item><title>Emacs 使用感受</title><link>https://fpghwd.github.io/posts/emacs-shi-yong-gan-shou/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
不知不觉使用 emacs 已经有两年了。其实一开始看 Emacs 那篇自带的极短的介绍要更早一点，现在看当时的那种喜悦的感觉（用上了众多名人都推荐的软件）更多的是 naive 和开心。
&lt;/p&gt;

&lt;p&gt;
后来从开始使用无配置的 emacs ，然后用 Spacemacs 的时候有眼前有一亮的感觉。然后逐渐学习使用 org-mode 并且针对 org-mode 进行自己的配置，也收获了很多开心的时光。
&lt;/p&gt;

&lt;p&gt;
慢慢的又转向使用 doom-emacs 感觉又有眼前一亮的感觉，主要是启动速度更快了，然后基本上开箱即用。然后也学到一些自己配置的方法，虽然 spacemacs 也可以自定义，但是启动一次还是蛮长的。
&lt;/p&gt;

&lt;p&gt;
然后逐渐学到了 org-roam, org-download, org-capture, org-pdftool 等等都是很好用的插件。不过现在已经很少纠结于配置了，现在的已经够用了。
&lt;/p&gt;

&lt;p&gt;
最后的最后，送一句传教语：
&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
Emacs loves me, emacs loves you.
&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-shi-yong-gan-shou/</guid><pubDate>Thu, 10 Dec 2020 10:23:53 GMT</pubDate></item><item><title>linux 平台下 emacs native-comp 分支编译</title><link>https://fpghwd.github.io/posts/linux-ping-tai-xia-emacs-native-comp-fen-zhi-bian-yi/</link><dc:creator>Wang Ding</dc:creator><description>&lt;ul class="org-ul"&gt;
&lt;li&gt;编译 libgccjit

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
下载 gcc
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;git clone git://gcc.gnu.org/git/gcc.git&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
然后切换到目录 &lt;code&gt;cd gcc&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
切换分枝
&lt;/p&gt;

&lt;p&gt;
切换 gcc-9 分枝 &lt;code&gt;git checkout remotes/origin/releases/gcc-9&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
创建 build 目录 &lt;code&gt;mkdir -p build&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
进入 build 目录 &lt;code&gt;cd build&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
configure
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;../configure --enable-host-shared --enable-languages=jit,c,c++,objc,obj-c++ --enable-checking=release --disable-bootstrap&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
编译
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;make -j8&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
安装（默认到 &lt;code&gt;/usr/local&lt;/code&gt; ）
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo make install&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
加载库
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo ldconfig&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
测试是否能发现 libgccjit 库 &lt;code&gt;sudo ldconfig -p | grep libgccjit&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;编译 emacs

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
下载 emacs
&lt;/p&gt;

&lt;p&gt;
克隆 emacs 仓库 &lt;code&gt;git clone https://github.com/emacs-mirror/emacs&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
进入 emacs 目录 &lt;code&gt;cd emacs&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
切换到 native-comp 分枝 &lt;code&gt;git checkout feature/native-comp&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
进入 emacs 目录后运行 autogen.sh
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;./autogen.sh&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
编译 emacs
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;./configure --with-nativecomp CC=clang&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
安装（默认 &lt;code&gt;/usr/local&lt;/code&gt; ）
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;sudo make install&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;启动 doom emacs

&lt;ol class="org-ol"&gt;
&lt;li&gt;&lt;p&gt;
&lt;del&gt;启动的时候如果报错&lt;/del&gt;
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;comp-deferred-compilation-black-list&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
然后找到&lt;a href="https://github.com/hlissner/doom-emacs/issues/4316"&gt;这里&lt;/a&gt;解决：注释掉 &lt;code&gt;.emacs.d/core/core.el&lt;/code&gt; 里面的一个过程 &lt;code&gt;(add-to-list 'comp-deferred-compilation-black-list entry)&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
doom build and run
&lt;/p&gt;

&lt;p&gt;
升级 doom ，包含 doom sync 和 doom build 过程 &lt;code&gt;doom upgrade&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
查看 doom 是否是使用 emacs 28 版本 &lt;code&gt;doom run --version&lt;/code&gt;
&lt;/p&gt;

&lt;p&gt;
若确认是 emacs 28 版本，就可运行 &lt;code&gt;doom run&lt;/code&gt;
&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;
最后
&lt;/p&gt;

&lt;p&gt;
确实有流畅很多，也可能是心理作用吧。 :)
&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/linux-ping-tai-xia-emacs-native-comp-fen-zhi-bian-yi/</guid><pubDate>Thu, 26 Nov 2020 09:53:27 GMT</pubDate></item><item><title>Difference Since Using Doom Emacs</title><link>https://fpghwd.github.io/posts/since-use-doom-emacs/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
自从使用了 doom emacs 后，就很少纠结系统升级了。以前没事总是会升级一下，但是现在最多的就是可能想起来会升级一下 doom emacs, 只需要在 emacs 中 upgrade 和 reload 即可。其实大多数时候我也只是 doom sync 一下配置然后 reload 一下，最多也就十几二十秒。
&lt;/p&gt;

&lt;p&gt;
用 emacs 写东西简直是最近感觉最幸福的一件事情了。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/since-use-doom-emacs/</guid><pubDate>Thu, 05 Nov 2020 03:13:58 GMT</pubDate></item><item><title>Emacs Lisp Overlay</title><link>https://fpghwd.github.io/posts/emacs-lisp-overlay/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近看到 Emacs Lisp 里面 Overlay 的概念，可以用于自定义介面 buffer 的文字的某些特殊效果。
&lt;/p&gt;

&lt;p&gt;
当然其实对文字的编辑和模式本身都可以是文字内容的一种展现方式，但是文字的属性（Text Properties）是文字的一部分，overlay 并不是文字的一部分。所以在 buffer 之间复制某些文字的时候，并不会同时复制  overlay ；同时改变 buffer 的文字属性其实也是在修改 buffer 本身。但 overlay 的改变并不会改变 buffer 本身，这种修改自然也不会被保存在这个 buffer 的 undo list 中。
&lt;/p&gt;&lt;/div&gt;</description><category>emacs</category><guid>https://fpghwd.github.io/posts/emacs-lisp-overlay/</guid><pubDate>Mon, 26 Oct 2020 13:24:03 GMT</pubDate></item><item><title>Org archive location</title><link>https://fpghwd.github.io/posts/org-archive-location/</link><dc:creator>Wang Ding</dc:creator><description>&lt;div&gt;&lt;p&gt;
最近在使用 org 的时候想把 org-archive-subtree 的条目和 org-capture-templates 那样，将每次当天 archived 的 headline 放到当日的日期 headline 下面，和日记一样组织。这样的话，将来查询的时候就可以顺便看一下当天发生的事情和当天完成的项目了。
&lt;/p&gt;

&lt;p&gt;
以下是日记的组织方式：
&lt;/p&gt;

&lt;div id="org595b26c" class="figure"&gt;
&lt;p&gt;&lt;img src="https://raw.githubusercontent.com/fpGHwd/fpghwd.github.io/master/images/_20201016_192526screenshot.png" alt="_20201016_192526screenshot.png"&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-lisp"&gt;
(add-to-list 'org-capture-templates
                      '("zj" "journal" entry (file "/home/wd/dropbox/to-encfs/text/org/journal.org")
                        "* %u - %^{heading}\n  %?"))

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
同时在 &lt;code&gt;customize org-archive-location&lt;/code&gt; 中发现了有这种设定：
&lt;/p&gt;

&lt;div class="org-src-container"&gt;

&lt;pre&gt;&lt;code class="lang-html"&gt;
"~/org/datetree.org::datetree/* Finished Tasks"
The "datetree/" string is special, signifying to archive
items to the datetree.  Items are placed in either the CLOSED
date of the item, or the current date if there is no CLOSED date.
The heading will be a subentry to the current date.  There doesn’t
need to be a heading, but there always needs to be a slash after
datetree.  For example, to store archived items directly in the
datetree, use "~/org/datetree.org::datetree/".

&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;p&gt;
可以把日记和归档的条目都放到一个文件，归档也不会经常去动，只需要看的时候搜索一下就行。
&lt;/p&gt;&lt;/div&gt;</description><category>ATTACH</category><category>emacs</category><guid>https://fpghwd.github.io/posts/org-archive-location/</guid><pubDate>Fri, 16 Oct 2020 11:32:18 GMT</pubDate></item></channel></rss>